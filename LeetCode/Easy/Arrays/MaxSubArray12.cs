namespace LeetCode.Easy.Arrays;

/// <summary>
/// 53. Maximum Subarray
/// Условие: найти подмассив с наибольшей суммой и вернуть эту сумму.
///
/// Подход (алгоритм Кадане):
/// 1. Поддерживаем две переменные: cur (текущая сумма) и best (лучшая сумма).
/// 2. Для каждого элемента: cur = max(nums[i], cur + nums[i]).
///    - Либо начинаем новый подмассив с nums[i].
///    - Либо продолжаем предыдущий подмассив.
/// 3. Обновляем best = max(best, cur).
///
/// Сложность:
/// - Время: O(n) — один проход по массиву
/// - Память: O(1) — только две переменные
///
/// Пример:
/// Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
/// Output: 6
/// Объяснение:
/// - Подмассив [4,-1,2,1] имеет наибольшую сумму = 6
/// - Алгоритм: cur начинается с -2, затем 1, затем -2, затем 4, затем 3, затем 5, затем 6...
/// </summary>
public class MaxSubArray12
{
    public int MaxSubArray(int[] nums)
    {
        int best = nums[0]; // лучшая сумма
        int cur = nums[0];  // текущая сумма

        for (int i = 1; i < nums.Length; i++)
        {
            // или продолжаем предыдущий подмассив, или начинаем новый с nums[i]
            cur = Math.Max(nums[i], cur + nums[i]);
            best = Math.Max(best, cur);
        }

        return best;
    }
}