namespace LeetCode.Easy.Arrays;

/// <summary>
/// 1. Two Sum
/// Условие: дан массив целых чисел nums и целое число target. Вернуть индексы двух чисел, сумма которых равна target.
/// Гарантируется, что существует ровно одно решение, и один элемент нельзя использовать дважды.
///
/// Подход (HashMap):
/// 1. Проходим по массиву один раз.
/// 2. Для каждого элемента вычисляем complement = target - nums[i].
/// 3. Если complement уже есть в словаре → нашли пару, возвращаем индексы.
/// 4. Иначе добавляем текущий элемент в словарь: nums[i] → i.
///
/// Сложность:
/// - Время: O(n) — один проход по массиву
/// - Память: O(n) — для хранения элементов в словаре
///
/// Пример:
/// Input: nums = [2,7,11,15], target = 9
/// Output: [0,1]
/// Объяснение:
/// - nums[0] = 2, complement = 9 - 2 = 7
/// - nums[1] = 7, находим 7 в словаре → пара найдена
/// - Возвращаем [0, 1]
/// </summary>
public class TwoSum1
{
    public int[] TwoSum(int[] nums, int target)
    {
        // Словарь: число -> индекс
        var map = new Dictionary<int, int>();

        for (int i = 0; i < nums.Length; i++)
        {
            int complement = target - nums[i]; // число, которое нужно найти
            
            // Если в словаре уже есть нужное число — возвращаем индексы
            if (map.ContainsKey(complement))
            {
                return [map[complement], i];
            }
            
            // Иначе добавляем текущее число в словарь
            map[nums[i]] = i;
        }

        // По условию задачи всегда есть одно решение
        return [];
    }
}