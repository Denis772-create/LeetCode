namespace LeetCode.Easy.BitManipulation;

/// <summary>
/// 338. Counting Bits
/// Условие: для каждого числа i от 0 до n включительно вернуть количество единиц в его двоичном представлении.
///
/// Подход (наивный):
/// 1. Для каждого числа от 0 до n:
///    - Подсчитываем количество единиц в двоичном представлении.
///    - Используем побитовые операции: x & 1 для проверки младшего бита, x >> 1 для сдвига.
/// 2. Сохраняем результат в массив.
///
/// Сложность:
/// - Время: O(n * log n) — для каждого числа проверяем все биты
/// - Память: O(1) вне результата
///
/// Пример:
/// Input: n = 2
/// Output: [0,1,1]
/// Объяснение:
/// - 0 в двоичном: 0 → 0 единиц
/// - 1 в двоичном: 1 → 1 единица
/// - 2 в двоичном: 10 → 1 единица
///
/// Пример 2:
/// Input: n = 5
/// Output: [0,1,1,2,1,2]
/// Объяснение:
/// - 0: 0 → 0 единиц
/// - 1: 1 → 1 единица
/// - 2: 10 → 1 единица
/// - 3: 11 → 2 единицы
/// - 4: 100 → 1 единица
/// - 5: 101 → 2 единицы
/// </summary>
public class Solution
{
    public int[] CountBits(int n)
    {
        var ans = new int[n + 1];

        for (var i = 0; i <= n; i++)
        {
            var x = i;
            var count = 0;
            
            // Считаем количество единиц в двоичном представлении i
            while (x > 0)
            {
                count += x & 1; // прибавляем младший бит
                x >>= 1;        // сдвигаем вправо
            }
            ans[i] = count;
        }
        return ans;
    }
}