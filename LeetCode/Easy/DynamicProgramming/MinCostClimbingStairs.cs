namespace LeetCode.Easy.DynamicProgramming;

/// <summary>
/// 746. Min Cost Climbing Stairs
/// Условие: дан массив cost, где cost[i] — это стоимость i-й ступеньки.
/// Можно подниматься на 1 или 2 ступеньки за раз. Нужно найти минимальную
/// стоимость, чтобы добраться до вершины (за пределы последней ступеньки).
///
/// Подход: используем динамическое программирование.
/// dp[i] — минимальная стоимость, чтобы добраться до ступеньки i.
/// Для каждой ступеньки i (начиная с 2):
///     dp[i] = cost[i] + min(dp[i - 1], dp[i - 2])
/// Ответом будет min(dp[n - 1], dp[n - 2]), поскольку можно закончить на
/// последней или предпоследней ступеньке.
///
/// Сложность:
/// - Время: O(n)
/// - Память: O(n)
///
/// Пример:
/// Input:
///     cost = [10,15,20]
/// Output: 15
/// Объяснение:
/// - Можно начать с индекса 1 (стоимость 15) и сразу подняться на вершину.
///     ⇒ минимальная стоимость = 15
///
/// Input:
///     cost = [1,100,1,1,1,100,1,1,100,1]
/// Output: 6
/// Объяснение:
/// - Оптимальный путь: 1 → 2 → 3 → 4 → 6 → 7 → вершина.
///     ⇒ сумма = 6
/// </summary>
public class MinCostClimbingStairsSolution
{
    public int MinCostClimbingStairs(int[] cost)
    {
        var n = cost.Length;

        if (n == 1) return 0;

        var dp = new int[n];
        dp[0] = cost[0];
        dp[1] = cost[1];

        for (int i = 2; i < n; i++)
        {
            dp[i] = Math.Min(dp[i - 2], dp[i - 1]) + cost[i];
        }

        return Math.Min(dp[n - 2], dp[n - 1]);
    }
}