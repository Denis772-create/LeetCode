namespace LeetCode.Medium.Arrays;

/// <summary>
/// 238. Product of Array Except Self
/// Условие: для каждого индекса выдать произведение всех элементов массива, кроме nums[i]. Без деления.
///
/// Идея (2 прохода, O(1) доп. памяти):
/// 1) Слева направо копим произведение всех элементов слева от i (prefix).
/// 2) Справа налево домножаем на произведение всех элементов справа от i (suffix).
///
/// Сложность:
/// - Время: O(n)
/// - Память: O(1) вне результата (не считая выходного массива)
///
/// Пример 1:
/// Input:  nums = [1,2,3,4]
/// Output: [24,12,8,6]
///
/// Пример 2 (с нулём):
/// Input:  nums = [-1,1,0,-3,3]
/// Output: [0,0,9,0,0]
/// </summary>
public class Lc0238ProductOfArrayExceptSelf
{
    public int[] ProductExceptSelf(int[] nums)
    {
        var n = nums.Length;
        var ans = new int[n];

        // left хранит произведение всех элементов слева от текущего индекса i.
        // На старте слева от i=0 ничего нет → 1 (нейтральный элемент умножения).
        var left = 1;
        for (var i = 0; i < n; i++)
        {
            ans[i] = left;
            left *= nums[i];
        }

        // right хранит произведение всех элементов справа от текущего индекса i.
        // Аналогично: справа от последнего индекса ничего нет → 1.
        var right = 1;
        for (var i = n - 1; i >= 0; i--)
        {
            ans[i] *= right;
            right *= nums[i];
        }

        return ans;
    }
}