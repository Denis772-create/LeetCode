namespace LeetCode.Medium.BinaryTreeDFS;

/// <summary>
/// 1448. Count Good Nodes in Binary Tree
/// Условие: узел считается "хорошим", если на пути от корня до этого узла
/// нет узлов со значением больше текущего. Вернуть количество "хороших" узлов.
///
/// Подход (DFS):
/// 1. Используем DFS для обхода дерева.
/// 2. На каждом шаге передаём максимальное значение на пути от корня.
/// 3. Если значение текущего узла >= максимуму на пути → узел "хороший".
/// 4. Обновляем максимум для потомков.
///
/// Сложность:
/// - Время: O(n), где n — количество узлов
/// - Память: O(h), где h — высота дерева (стек рекурсии)
///
/// Пример:
/// Input:
///        3
///       / \
///      1   4
///     /   / \
///    3   1   5
/// Output: 4
/// Объяснение:
/// - Узел 3 (корень) — хороший (нет узлов выше)
/// - Узел 1 (левый) — не хороший (3 > 1)
/// - Узел 3 (левый потомок 1) — хороший (3 >= 3)
/// - Узел 4 — хороший (4 >= 3)
/// - Узел 1 (правый потомок 4) — не хороший (4 > 1)
/// - Узел 5 — хороший (5 >= 4)
/// </summary>
public class Solution134
{
    // Определение узла бинарного дерева
    public class TreeNode(int val = 0, TreeNode? left = null, TreeNode? right = null)
    {
        public int val = val;
        public TreeNode? left = left;
        public TreeNode? right = right;
    }

    public int GoodNodes(TreeNode root)
    {
        // Корень всегда "good".
        // Запускаем DFS, передавая "максимум на пути" = значение корня.
        return Dfs(root, root.val);
    }

    // Рекурсивная функция: возвращает, сколько "good" узлов в поддереве node,
    // если по пути сверху максимальное значение равно maxSoFar.
    private int Dfs(TreeNode? node, int maxSoFar)
    {
        // База: дошли до пустой ветки — хороших узлов нет.
        if (node == null) return 0;
        
        // Текущий узел "good", если его значение >= максимуму на пути.
        var isGood = node.val >= maxSoFar ? 1 : 0;
        
        // Обновляем максимум на пути: возможно, текущий узел — новый максимум.
        var newMax = Math.Max(maxSoFar, node.val);
        
        // Идём влево и вправо, передавая обновлённый максимум.
        var leftGood = Dfs(node.left, newMax);
        var rightGood = Dfs(node.right, newMax);
        
        // Возвращаем общее количество "good": текущий + слева + справа.
        return isGood + leftGood + rightGood;
    }
}