namespace LeetCode.Medium.GraphsBFS;

using System.Collections.Generic;

/// <summary>
/// 1926. Nearest Exit from Entrance in Maze
/// Условие: найти кратчайший путь от входа до ближайшего выхода в лабиринте.
/// Выход — это пустая клетка на границе лабиринта (но не сам вход).
///
/// Подход (BFS):
/// 1. Используем BFS для поиска кратчайшего пути.
/// 2. Начинаем с входа, помечаем его как посещённый.
/// 3. На каждом шаге проверяем все 4 направления.
/// 4. Если достигли границы (и это не вход) → нашли выход, возвращаем расстояние.
/// 5. Иначе добавляем соседние пустые клетки в очередь.
///
/// Сложность:
/// - Время: O(m * n), где m и n — размеры лабиринта
/// - Память: O(m * n) — для очереди и массива visited
///
/// Пример:
/// Input:
/// maze = [["+","+",".","+"],
///         [".",".",".","+"],
///         ["+","+","+","."]]
/// entrance = [1,2]
/// Output: 1
/// Объяснение: кратчайший путь от входа до выхода — 1 шаг
/// </summary>
public class Solution
{
    public int NearestExit(char[][] maze, int[] entrance)
    {
        // m — число строк (высота лабиринта)
        var m = maze.Length;

        // n — число столбцов (ширина лабиринта)
        var n = maze[0].Length;

        // dirs — 4 возможных направления движения:
        // вверх (-1,0), вниз (1,0), влево (0,-1), вправо (0,1)s
        var dirs = new int[][]
        {
            [-1, 0],
            [1, 0],
            [0,-1],
            [0, 1]
        };

        // visited[r, c] — посещали ли мы клетку (r,c).
        // Нужен, чтобы не зациклиться и не заходить повторно в те же клетки.
        var visited = new bool[m, n];

        // Очередь для BFS: каждый элемент — кортеж (r, c, dist),
        // где r,c — координаты клетки, а dist — число шагов от старта (входа).
        var q = new Queue<(int r, int c, int dist)>();

        // sr, sc — координаты входа (start row, start col).
        int sr = entrance[0], sc = entrance[1];

        // Вход — исходная точка. Отмечаем её как посещённую,
        // чтобы потом не считать её "выходом" и не добавлять повторно в очередь.
        visited[sr, sc] = true;

        // Кладём стартовую клетку в очередь с расстоянием 0 (мы ещё никуда не шагали).
        q.Enqueue((sr, sc, 0));

        // Классический цикл BFS: пока есть клетки в очереди, продолжаем обход.
        while (q.Count > 0)
        {
            // Берём из очереди первую клетку (FIFO).
            var (r, c, dist) = q.Dequeue();

            // Пробуем пойти во все 4 стороны от текущей клетки.
            foreach (var d in dirs)
            {
                // Вычисляем координаты соседней клетки.
                var nr = r + d[0];
                var nc = c + d[1];

                // Проверяем три условия:
                // 1) Сосед внутри границ лабиринта.
                // 2) Это пустая клетка '.' (а не стена '+').
                // 3) Мы ещё не были в этой клетке.
                if (nr >= 0 && nr < m && nc >= 0 && nc < n
                    && maze[nr][nc] == '.' && !visited[nr, nc])
                {
                    // Если соседняя пустая клетка — на границе (border)
                    // и это не сама стартовая клетка (вход не считается выходом),
                    // значит, мы нашли ближайший выход.
                    // Возвращаем dist + 1, потому что мы делаем ещё один шаг из (r,c) в (nr,nc).
                    if (IsBorder(nr, nc, m, n) && !(nr == sr && nc == sc))
                        return dist + 1;

                    // Иначе — отмечаем её как посещённую,
                    // чтобы в будущем сюда не зайти второй раз.
                    visited[nr, nc] = true;

                    // И добавляем в очередь с расстоянием dist + 1,
                    // потому что до неё на один шаг дальше, чем до текущей (r,c).
                    q.Enqueue((nr, nc, dist + 1));
                }
            }
        }

        // Если очередь опустела и мы так и не нашли ни одного выхода,
        // то ближайшего выхода не существует — возвращаем -1.
        return -1;
    }

    // Вспомогательная функция: проверяет, лежит ли клетка (r,c)
    // на границе лабиринта размером m x n.
    private bool IsBorder(int r, int c, int m, int n)
    {
        // Клетка на границе, если её строка — верхняя (0) или нижняя (m-1),
        // или её столбец — левый (0) или правый (n-1).
        return r == 0 || r == m - 1 || c == 0 || c == n - 1;
    }
}
