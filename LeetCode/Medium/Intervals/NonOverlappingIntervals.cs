namespace LeetCode.Medium.Intervals;

/// <summary>
/// 435. Non-overlapping Intervals
/// Условие: найти минимальное количество интервалов, которые нужно удалить, чтобы остальные не пересекались.
///
/// Подход (жадный алгоритм):
/// 1. Сортируем интервалы по правому концу (концу интервала).
/// 2. Жадно выбираем интервалы: берём интервал с наименьшим правым концом.
/// 3. Если следующий интервал начинается после конца текущего → он не пересекается, берём его.
/// 4. Иначе пропускаем (он пересекается с уже выбранным).
/// 5. Минимум удалений = общее количество - максимум выбранных.
///
/// Сложность:
/// - Время: O(n log n) — из-за сортировки
/// - Память: O(1) вне сортировки
///
/// Пример:
/// Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
/// Output: 1
/// Объяснение:
/// - После сортировки: [[1,2],[2,3],[1,3],[3,4]]
/// - Выбираем: [1,2], [2,3], [3,4] (3 интервала)
/// - Удаляем: [1,3] (1 интервал)
/// </summary>
public class Solution
{
    public int EraseOverlapIntervals(int[][] intervals)
    {
        if (intervals == null || intervals.Length <= 1) return 0;
        
        Array.Sort(intervals, (a, b) => a[1].CompareTo(b[1]));
        
        // 2) жадно набираем максимум непересекающихся интервалов
        var taken = 0;
        var lastEnd = int.MinValue;

        foreach (var it in intervals)
        {
            int start = it[0], end = it[1];
            
            // "касаются" допустимо: start >= lastEnd
            if (start >= lastEnd)
            {
                taken++;
                lastEnd = end;
            }
        }
        
        // 3) минимум удалений = все - максимум оставленных
        return intervals.Length - taken;
    }
}