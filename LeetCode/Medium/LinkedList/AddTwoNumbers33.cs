namespace LeetCode.Medium.LinkedList;

/// <summary>
/// 2. Add Two Numbers
/// Условие: даны два непустых односвязных списка, представляющих два неотрицательных числа.
/// Цифры хранятся в обратном порядке. Вернуть сумму в виде односвязного списка.
///
/// Подход (симуляция сложения):
/// 1. Используем фиктивную голову для упрощения логики.
/// 2. Проходим оба списка одновременно, складывая соответствующие цифры.
/// 3. Учитываем перенос (carry) от предыдущего разряда.
/// 4. Создаём новый узел для каждой цифры результата.
///
/// Сложность:
/// - Время: O(max(n, m)), где n и m — длины списков
/// - Память: O(max(n, m)) — для результирующего списка
///
/// Пример:
/// Input: l1 = [2,4,3], l2 = [5,6,4]
/// Представляет: 342 + 465 = 807
/// Output: [7,0,8]
/// Объяснение: 2+5=7, 4+6=10 (пишем 0, перенос 1), 3+4+1=8
/// </summary>
public class AddTwoNumbers33
{
    public class ListNode(int val = 0, ListNode next = null)
    {
        public int val = val;
        public ListNode next = next;
    }
    
    public ListNode AddTwoNumbers(ListNode l1, ListNode l2)
    {
        // Перенос (то, что "в уме")
        var carry = 0;
        
        // Фиктивная голова результирующего списка
        var dummy = new ListNode();
        var current = dummy;
        
        // Пока есть цифры в списках или есть перенос
        while (l1 != null || l2 != null || carry != 0)
        {
            // Берём цифры или 0, если список закончился
            var x = l1?.val ?? 0;
            var y = l2?.val ?? 0;
            
            // Складываем
            var total = x + y + carry;
            
            // Создаём узел с цифрой результата
            current.next = new ListNode(total % 10);

            // Обновляем перенос
            carry = total / 10;
            
            // Сдвигаем указатель результата
            current = current.next;
            
            // Переходим к следующим узлам
            l1 = l1?.next;
            l2 = l2?.next;
        }
        
        // Возвращаем голову нового списка
        return dummy.next;
    }
}