namespace LeetCode.Medium.Strings;

/// <summary>
/// 443. String Compression
/// Условие: выполнить сжатие массива символов на месте.
/// Если символ повторяется k раз подряд, записать его и число k (по цифрам).
///
/// Пример:
/// Input:  chars = ['a','a','b','b','c','c','c']
/// Output: ['a','2','b','2','c','3'], length = 6
///
/// Объяснение:
/// - 'a' встречается 2 раза → 'a','2'
/// - 'b' встречается 2 раза → 'b','2'
/// - 'c' встречается 3 раза → 'c','3'
///
/// Ещё пример:
/// Input:  chars = ['a']
/// Output: ['a'], length = 1
///
/// Input:  chars = ['a','b','b','b','b','b','b','b','b','b','b']
/// Output: ['a','b','1','0'], length = 4
///
/// Подход:
/// 1. Два указателя: i — для чтения, write — для записи.
/// 2. Для каждой группы одинаковых символов считаем количество повторений.
/// 3. Записываем сам символ и его count (если больше 1).
///
/// Сложность:
/// - Время: O(n)
/// - Память: O(1)
/// </summary>
public class Lc0443StringCompression
{
    public int Compress(char[] chars)
    {
        var write = 0; // куда записывать результат
        var i = 0;     // текущая позиция чтения

        while (i < chars.Length)
        {
            var c = chars[i]; // текущий символ
            var count = 0;

            // Считаем, сколько одинаковых подряд
            while (i < chars.Length && chars[i] == c)
            {
                i++;
                count++;
            }

            // Записываем сам символ
            chars[write++] = c;

            // Если повторов больше 1 — записываем число по цифрам
            if (count > 1)
            {
                foreach (var d in count.ToString())
                {
                    chars[write++] = d;
                }
            }
        }

        // Возвращаем новую длину сжатого массива
        return write;
    }
}