namespace LeetCode.Medium.TwoPointers;

/// <summary>
/// 1493. Longest Subarray of 1's After Deleting One Element
/// Условие: нужно удалить ровно один элемент из массива (0 или 1),
/// чтобы длина самого длинного подмассива, состоящего только из единиц, стала максимальной.
///
/// Подход (скользящее окно / два указателя):
/// - Держим окно [left, right], внутри которого не больше одного нуля.
/// - Когда нулей становится больше одного, сдвигаем left, пока условие снова не выполнится.
/// - На каждом шаге считаем длину окна без одного удалённого элемента → (right - left).
///
/// Сложность:
/// - Время: O(n)
/// - Память: O(1)
///
/// Пример 1:
/// Input:  [1,1,0,1]
/// Процесс:
/// right=0 → [1] → zeros=0 → best=0-0=0  
/// right=1 → [1,1] → zeros=0 → best=1-0=1  
/// right=2 → [1,1,0] → zeros=1 → best=2-0=2  
/// right=3 → [1,1,0,1] → zeros=1 → best=3-0=3 ✅
/// Output: 3
///
/// Пример 2:
/// Input:  [0,1,1,1,0,1,1,0,1]
/// Самое длинное окно с ≤1 нулём — [1,1,1,0,1,1] → длина 6, но нужно вычесть 1 удалённый элемент.
/// Output: 5
///
/// Объяснение:
/// Можно удалить любой один 0 внутри, и останется подмассив из пяти 1 подряд.
/// </summary>
public class Lc1493LongestSubarrayOf1sAfterDeletingOneElement
{
    public int LongestSubarray(int[] nums)
    {
        var left = 0;   // левая граница окна
        var zeros = 0;  // количество нулей в окне
        var best = 0;   // лучший результат

        for (var right = 0; right < nums.Length; right++)
        {
            // Расширяем окно вправо
            if (nums[right] == 0)
                zeros++;

            // Если нулей стало больше одного — сдвигаем левую границу
            while (zeros > 1)
            {
                if (nums[left] == 0)
                    zeros--;
                left++;
            }

            // right - left = длина окна - 1 (т.к. один элемент удаляется)
            best = Math.Max(best, right - left);
        }

        return best;
    }
}